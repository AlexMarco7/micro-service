// Generated by typings
// Source: https://raw.githubusercontent.com/types/npm-when/5e05a8f9b38372953ceafa57603be8fe1623e32f/2/index.d.ts
declare module '~amqplib~when' {
// Type definitions for When 2.4.0
// Project: https://github.com/cujojs/when
// Definitions by: Derek Cicerone <https://github.com/derekcicerone>, Wim Looman <https://github.com/Nemo157>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped

function When<T>(value: When.Promise<T>): When.Promise<T>;
function When<T>(value: When.Thenable<T>): When.Promise<T>;
function When<T>(value: T): When.Promise<T>;

function When<T, U>(value: When.Promise<T>, transform: (val: T) => U): When.Promise<U>;
function When<T, U>(value: When.Thenable<T>, transform: (val: T) => U): When.Promise<U>;
function When<T, U>(value: T, transform: (val: T) => U): When.Promise<U>;

namespace When {
    // Helper interfaces
    namespace _ {
        interface Fn0<T> { (): T }
        interface Fn1<A1, T> { (a1: A1): T }
        interface Fn2<A1, A2, T> { (a1: A1, a2: A2): T }
        interface Fn3<A1, A2, A3, T> { (a1: A1, a2: A2, a3: A3): T }
        interface Fn4<A1, A2, A3, A4, T> { (a1: A1, a2: A2, a3: A3, a4: A4): T }
        interface Fn5<A1, A2, A3, A4, A5, T> { (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5): T }
        interface Fn6<A1, A2, A3, A4, A5, A6, T> { (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6): T }

        interface LiftedFn0<T> extends Fn0<Promise<T>> { }
        interface LiftedFn1<A1, T> extends Fn1<A1 | Promise<A1>, Promise<T>> { }
        interface LiftedFn2<A1, A2, T> extends Fn2<A1 | Promise<A1>, A2 | Promise<A2>, Promise<T>> { }
        interface LiftedFn3<A1, A2, A3, T> extends Fn3<A1 | Promise<A1>, A2 | Promise<A2>, A3 | Promise<A3>, Promise<T>> { }
        interface LiftedFn4<A1, A2, A3, A4, T> extends Fn4<A1 | Promise<A1>, A2 | Promise<A2>, A3 | Promise<A3>, A4 | Promise<A4>, Promise<T>> { }
        interface LiftedFn5<A1, A2, A3, A4, A5, T> extends Fn5<A1 | Promise<A1>, A2 | Promise<A2>, A3 | Promise<A3>, A4 | Promise<A4>, A5 | Promise<A5>, Promise<T>> { }

        interface NodeCallback<T> { (err: any, result: T): void }

        interface NodeFn0<T> extends _.Fn1<NodeCallback<T>, void> { }
        interface NodeFn1<A1, T> extends _.Fn2<A1, NodeCallback<T>, void> { }
        interface NodeFn2<A1, A2, T> extends _.Fn3<A1, A2, NodeCallback<T>, void> { }
        interface NodeFn3<A1, A2, A3, T> extends _.Fn4<A1, A2, A3, NodeCallback<T>, void> { }
        interface NodeFn4<A1, A2, A3, A4, T> extends _.Fn5<A1, A2, A3, A4, NodeCallback<T>, void> { }
        interface NodeFn5<A1, A2, A3, A4, A5, T> extends _.Fn6<A1, A2, A3, A4, A5, NodeCallback<T>, void> { }
    }

    function attempt<T>(
        f: _.Fn0<T>
    ): Promise<T>;

    function attempt<A1, T>(
        f: _.Fn1<A1, T>,
        arg1: A1 | Promise<A1>
    ): Promise<T>;

    function attempt<A1, A2, T>(
        f: _.Fn2<A1, A2, T>,
        arg1: A1 | Promise<A1>,
        arg2: A2 | Promise<A2>
    ): Promise<T>;

    function attempt<A1, A2, A3, T>(
        f: _.Fn3<A1, A2, A3, T>,
        arg1: A1 | Promise<A1>,
        arg2: A2 | Promise<A2>,
        arg3: A3 | Promise<A3>
    ): Promise<T>;

    function attempt<A1, A2, A3, A4, T>(
        f: _.Fn4<A1, A2, A3, A4, T>,
        arg1: A1 | Promise<A1>,
        arg2: A2 | Promise<A2>,
        arg3: A3 | Promise<A3>,
        arg4: A4 | Promise<A4>
    ): Promise<T>;

    function attempt<A1, A2, A3, A4, A5, T>(
        f: _.Fn5<A1, A2, A3, A4, A5, T>,
        arg1: A1 | Promise<A1>,
        arg2: A2 | Promise<A2>,
        arg3: A3 | Promise<A3>,
        arg4: A4 | Promise<A4>,
        arg5: A5 | Promise<A5>
    ): Promise<T>;


    function lift<T>(f: _.Fn0<T>): _.LiftedFn0<T>;
    function lift<A1, T>(f: _.Fn1<A1, T>): _.LiftedFn1<A1, T>;
    function lift<A1, A2, T>(f: _.Fn2<A1, A2, T>): _.LiftedFn2<A1, A2, T>;
    function lift<A1, A2, A3, T>(f: _.Fn3<A1, A2, A3, T>): _.LiftedFn3<A1, A2, A3, T>;
    function lift<A1, A2, A3, A4, T>(f: _.Fn4<A1, A2, A3, A4, T>): _.LiftedFn4<A1, A2, A3, A4, T>;
    function lift<A1, A2, A3, A4, A5, T>(f: _.Fn5<A1, A2, A3, A4, A5, T>): _.LiftedFn5<A1, A2, A3, A4, A5, T>;

    function promise<T>(resolver: (resolve: (value: T) => void, reject: (reason: any) => void) => void): Promise<T>;

    function reject<T>(reason: any): Promise<T>;

    /**
     * Return a promise that will resolve only once all the supplied promisesOrValues
     * have resolved. The resolution value of the returned promise will be an array
     * containing the resolution values of each of the promisesOrValues.
     * @memberOf when
     *
     * @param promisesOrValues array of anything, may contain a mix
     *      of {@link Promise}s and values
     */
    function all<T>(promisesOrValues: any[]): Promise<T>;

    /**
     * Describes the status of a promise.
     * state may be one of:
     * "fulfilled" - the promise has resolved
     * "pending" - the promise is still pending to resolve/reject
     * "rejected" - the promise has rejected
     */
    interface Descriptor<T> {
        state: string;
        value?: T;
        reason?: any;
    }

    /**
     * Returns a promise for an array containing the same number of elements as the input array.
     * Each element is a descriptor object describing of the outcome of the corresponding element in the input.
     * The returned promise will only reject if array itself is a rejected promise. Otherwise,
     * it will always fulfill with an array of descriptors. This is in contrast to when.all,
     * which will reject if any element of array rejects.
     * @memberOf when
     *
     * @param promisesOrValues array of anything, may contain a mix
     *      of {@link Promise}s and values
     */
    function settle<T>(promisesOrValues: any[]): Promise<Descriptor<T>[]>;

    /**
     * Generates a potentially infinite stream of promises by repeatedly calling f until predicate becomes true.
     * @memberOf when
     * @param f function that, given a seed, returns the next value or a promise for it.
     * @param predicate function that receives the current iteration value, and should return truthy when the iterating should stop
     * @param handler function that receives each value as it is produced by f. It may return a promise to delay the next iteration.
     * @param seed initial value provided to the handler, and first f invocation. May be a promise.
     */
    function iterate<U>(f: (seed: U) => U | Promise<U>,
        predicate: (value: U) => boolean,
        handler: (value: U) => Promise<any> | void,
        seed: U | Promise<U>): Promise<U>;


    /**
     * Similar to when/iterate, when.unfold generates a potentially infinite stream of promises by repeatedly calling
     * unspool until predicate becomes true. when.unfold allows you to thread additional state information through the iteration.
     * @memberOf when
     * @param unspool function that, given a seed, returns a [valueToSendToHandler, newSeed] pair.
     * May return an array, array of promises, promise for an array, or promise for an array of promises.
     * @param predicate function that receives the current seed, and should return truthy when the unfold should stop
     * @param handler function that receives the valueToSendToHandler of the current iteration.
     * This function can process valueToSendToHandler in whatever way you need.
     * It may return a promise to delay the next iteration of the unfold.
     * @param seed initial value provided to the first unspool invocation. May be a promise.
     */
    function unfold<T, U>(unspool: (seed: U) => [T | Promise<T>, U | Promise<U>] | Promise<[T | Promise<T>, U | Promise<U>]>,
        predicate: (value: U) => boolean | Promise<boolean>,
        handler: (value: T) => Promise<any> | void,
        seed: U | Promise<U>): Promise<void>;

    /**
     * Creates a {promise, resolver} pair, either or both of which
     * may be given out safely to consumers.
     * The resolver has resolve, reject, and progress.  The promise
     * has then plus extended promise API.
     */
    function defer<T>(): Deferred<T>;

    /**
     * Joins multiple promises into a single returned promise.
     * @return a promise that will fulfill when *all* the input promises
     * have fulfilled, or will reject when *any one* of the input promises rejects.
     */
    function join<T>(...promises: Promise<T>[]): Promise<T[]>;
    /**
     * Joins multiple promises into a single returned promise.
     * @return a promise that will fulfill when *all* the input promises
     * have fulfilled, or will reject when *any one* of the input promises rejects.
     */
    function join<T>(...promises: any[]): Promise<T[]>;

    /**
     * Returns a resolved promise. The returned promise will be
     *  - fulfilled with promiseOrValue if it is a value, or
     *  - if promiseOrValue is a promise
     *    - fulfilled with promiseOrValue's value after it is fulfilled
     *    - rejected with promiseOrValue's reason after it is rejected
     */
    function resolve<T>(promise: Promise<T>): Promise<T>;
    function resolve<T>(foreign: Thenable<T>): Promise<T>;
    function resolve<T>(value?: T): Promise<T>;

    interface Deferred<T> {
        notify(update: any): void;
        promise: Promise<T>;
        reject(reason: any): void;
        resolve(value?: T): void;
        resolve(value?: Promise<T>): void;
    }

    interface Promise<T> {
        catch<U>(onRejected?: (reason: any) => U | Promise<U>): Promise<U>;

        catch<U>(filter: (reason: any) => boolean, onRejected?: (reason: any) => U | Promise<U>): Promise<U>;

        // Make sure you test any usage of these overloads, exceptionType must
        // be a constructor with prototype set to an instance of Error.
        catch<U>(exceptionType: any, onRejected?: (reason: any) => U | Promise<U>): Promise<U>;

        finally(onFulfilledOrRejected: Function): Promise<T>;

        ensure(onFulfilledOrRejected: Function): Promise<T>;

        inspect(): Snapshot<T>;

        yield<U>(value: U | Promise<U>): Promise<U>;

        else(value: T): Promise<T>;
        orElse(value: T): Promise<T>;

        tap(onFulfilledSideEffect: (value: T) => void): Promise<T>;

        delay(milliseconds: number): Promise<T>;

        timeout(milliseconds: number, reason?: any): Promise<T>;

        with(thisArg: any): Promise<T>;
        withThis(thisArg: any): Promise<T>;

        otherwise<U>(onRejected?: (reason: any) => U | Promise<U>): Promise<U>;

        otherwise<U>(predicate: (reason: any) => boolean, onRejected?: (reason: any) => U | Promise<U>): Promise<U>;

        // Make sure you test any usage of these overloads, exceptionType must
        // be a constructor with prototype set to an instance of Error.
        otherwise<U>(exceptionType: any, onRejected?: (reason: any) => U | Promise<U>): Promise<U>;

        then<U>(onFulfilled: (value: T) => U | Promise<U>, onRejected?: (reason: any) => U | Promise<U>, onProgress?: (update: any) => void): Promise<U>;

        spread<T>(onFulfilled: _.Fn0<Promise<T> | T>): Promise<T>;
        spread<A1, T>(onFulfilled: _.Fn1<A1, Promise<T> | T>): Promise<T>;
        spread<A1, A2, T>(onFulfilled: _.Fn2<A1, A2, Promise<T> | T>): Promise<T>;
        spread<A1, A2, A3, T>(onFulfilled: _.Fn3<A1, A2, A3, Promise<T> | T>): Promise<T>;
        spread<A1, A2, A3, A4, T>(onFulfilled: _.Fn4<A1, A2, A3, A4, Promise<T> | T>): Promise<T>;
        spread<A1, A2, A3, A4, A5, T>(onFulfilled: _.Fn5<A1, A2, A3, A4, A5, Promise<T> | T>): Promise<T>;

        done<U>(onFulfilled: (value: T) => void, onRejected?: (reason: any) => void): void;

        fold<U, V>(combine: (value1: T, value2: V) => U | Promise<U>, value2: V | Promise<V>): Promise<U>;
    }

    interface Thenable<T> {
        then<U>(onFulfilled: (value: T) => U, onRejected?: (reason: any) => U): Thenable<U>;
    }

    interface Snapshot<T> {
        state: string;
        value?: T;
        reason?: any;
    }
}

export = When;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/louy/typed-amqplib/bf1d0be483a12e7ad9b717b97019fcd9bf4058dc/properties.d.ts
declare module '~amqplib/properties' {
export namespace Replies {
    interface Empty {
    }
    interface AssertQueue {
        queue: string;
        messageCount: number;
        consumerCount: number;
    }
    interface PurgeQueue {
        messageCount: number;
    }
    interface DeleteQueue {
        messageCount: number;
    }
    interface AssertExchange {
        exchange: string;
    }
    interface Consume {
        consumerTag: string;
    }
}

export namespace Options {
    interface AssertQueue {
        exclusive?: boolean;
        durable?: boolean;
        autoDelete?: boolean;
        arguments?: any;
        messageTtl?: number;
        expires?: number;
        deadLetterExchange?: string;
        deadLetterRoutingKey?: string;
        maxLength?: number;
    }
    interface DeleteQueue {
        ifUnused?: boolean;
        ifEmpty?: boolean;
    }
    interface AssertExchange {
        durable?: boolean;
        internal?: boolean;
        autoDelete?: boolean;
        alternateExchange?: string;
        arguments?: any;
    }
    interface DeleteExchange {
        ifUnused?: boolean;
    }
    interface Publish {
        expiration?: string;
        userId?: string;
        CC?: string | string[];

        mandatory?: boolean;
        persistent?: boolean;
        deliveryMode?: boolean | number;
        BCC?: string | string[];

        contentType?: string;
        contentEncoding?: string;
        headers?: any;
        priority?: number;
        correlationId?: string;
        replyTo?: string;
        messageId?: string;
        timestamp?: number;
        type?: string;
        appId?: string;
    }
    interface Consume {
        consumerTag?: string;
        noLocal?: boolean;
        noAck?: boolean;
        exclusive?: boolean;
        priority?: number;
        arguments?: any;
    }
    interface Get {
        noAck?: boolean;
    }
}

export interface Message {
    content: Buffer;
    fields: any;
    properties: any;
}
}
declare module 'amqplib/properties' {
export * from '~amqplib/properties';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/louy/typed-amqplib/bf1d0be483a12e7ad9b717b97019fcd9bf4058dc/callback_api.d.ts
declare module '~amqplib/callback_api' {
import events = require('events');
import shared = require('~amqplib/properties')

export import Replies = shared.Replies;
export import Options = shared.Options;
export import Message = shared.Message;

export interface Connection extends events.EventEmitter {
    close(callback?: (err: any) => void): void;
    createChannel(callback: (err: any, channel: Channel) => void): void;
    createConfirmChannel(callback: (err: any, confirmChannel: ConfirmChannel) => void): void;
}

export interface Channel extends events.EventEmitter {
    close(callback: (err: any) => void): void;

    assertQueue(queue?: string, options?: Options.AssertQueue, callback?: (err: any, ok: Replies.AssertQueue) => void): void;
    checkQueue(queue: string, callback?: (err: any, ok: Replies.AssertQueue) => void): void;

    deleteQueue(queue: string, options?: Options.DeleteQueue, callback?: (err: any, ok: Replies.DeleteQueue) => void): void;
    purgeQueue(queue: string, callback?: (err: any, ok: Replies.PurgeQueue) => void): void;

    bindQueue(queue: string, source: string, pattern: string, args?: any, callback?: (err: any, ok: Replies.Empty) => void): void;
    unbindQueue(queue: string, source: string, pattern: string, args?: any, callback?: (err: any, ok: Replies.Empty) => void): void;

    assertExchange(exchange: string, type: string, options?: Options.AssertExchange, callback?: (err: any, ok: Replies.AssertExchange) => void): void;
    checkExchange(exchange: string, callback?: (err: any, ok: Replies.Empty) => void): void;

    deleteExchange(exchange: string, options?: Options.DeleteExchange, callback?: (err: any, ok: Replies.Empty) => void): void;

    bindExchange(destination: string, source: string, pattern: string, args?: any, callback?: (err: any, ok: Replies.Empty) => void): void;
    unbindExchange(destination: string, source: string, pattern: string, args?: any, callback?: (err: any, ok: Replies.Empty) => void): void;

    publish(exchange: string, routingKey: string, content: Buffer, options?: Options.Publish): boolean;
    sendToQueue(queue: string, content: Buffer, options?: Options.Publish): boolean;

    consume(queue: string, onMessage: (msg: Message) => any, options?: Options.Consume, callback?: (err: any, ok: Replies.Consume) => void): void;

    cancel(consumerTag: string, callback?: (err: any, ok: Replies.Empty) => void): void;
    get(queue: string, options?: Options.Get, callback?: (err: any, ok: Message | boolean) => void): void;

    ack(message: Message, allUpTo?: boolean): void;
    ackAll(): void;

    nack(message: Message, allUpTo?: boolean, requeue?: boolean): void;
    nackAll(requeue?: boolean): void;
    reject(message: Message, requeue?: boolean): void;

    prefetch(count: number, global?: boolean): void;
    recover(callback?: (err: any, ok: Replies.Empty) => void): void;
}

export interface ConfirmChannel extends Channel {
    publish(exchange: string, routingKey: string, content: Buffer, options?: Options.Publish, callback?: (err: any, ok: Replies.Empty) => void): boolean;
    sendToQueue(queue: string, content: Buffer, options?: Options.Publish, callback?: (err: any, ok: Replies.Empty) => void): boolean;

    waitForConfirms(callback?: (err: any) => void): void;
}

export function connect(callback: (err: any, connection: Connection) => void): void;
export function connect(url: string, callback: (err: any, connection: Connection) => void): void;
export function connect(url: string, socketOptions: any, callback: (err: any, connection: Connection) => void): void;
}
declare module 'amqplib/callback_api' {
export * from '~amqplib/callback_api';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/louy/typed-amqplib/bf1d0be483a12e7ad9b717b97019fcd9bf4058dc/channel_api.d.ts
declare module 'amqplib' {
import events = require('events');
import when = require('~amqplib~when');
import shared = require('~amqplib/properties');
import callback_api = require('~amqplib/callback_api');

export import Replies = shared.Replies;
export import Options = shared.Options;
export import Message = shared.Message;

export interface Connection extends events.EventEmitter {
    close(): when.Promise<void>;
    createChannel(): when.Promise<Channel>;
    createConfirmChannel(): when.Promise<Channel>;
}

export interface Channel extends events.EventEmitter {
    close(): when.Promise<void>;

    assertQueue(queue: string, options?: Options.AssertQueue): when.Promise<Replies.AssertQueue>;
    checkQueue(queue: string): when.Promise<Replies.AssertQueue>;

    deleteQueue(queue: string, options?: Options.DeleteQueue): when.Promise<Replies.DeleteQueue>;
    purgeQueue(queue: string): when.Promise<Replies.PurgeQueue>;

    bindQueue(queue: string, source: string, pattern: string, args?: any): when.Promise<Replies.Empty>;
    unbindQueue(queue: string, source: string, pattern: string, args?: any): when.Promise<Replies.Empty>;

    assertExchange(exchange: string, type: string, options?: Options.AssertExchange): when.Promise<Replies.AssertExchange>;
    checkExchange(exchange: string): when.Promise<Replies.Empty>;

    deleteExchange(exchange: string, options?: Options.DeleteExchange): when.Promise<Replies.Empty>;

    bindExchange(destination: string, source: string, pattern: string, args?: any): when.Promise<Replies.Empty>;
    unbindExchange(destination: string, source: string, pattern: string, args?: any): when.Promise<Replies.Empty>;

    publish(exchange: string, routingKey: string, content: Buffer, options?: Options.Publish): boolean;
    sendToQueue(queue: string, content: Buffer, options?: Options.Publish): boolean;

    consume(queue: string, onMessage: (msg: Message) => any, options?: Options.Consume): when.Promise<Replies.Consume>;

    cancel(consumerTag: string): when.Promise<Replies.Empty>;
    get(queue: string, options?: Options.Get): when.Promise<Message | boolean>;

    ack(message: Message, allUpTo?: boolean): void;
    ackAll(): void;

    nack(message: Message, allUpTo?: boolean, requeue?: boolean): void;
    nackAll(requeue?: boolean): void;
    reject(message: Message, requeue?: boolean): void;

    prefetch(count: number, global?: boolean): when.Promise<Replies.Empty>;
    recover(): when.Promise<Replies.Empty>;
}

export function connect(url: string, socketOptions?: any): when.Promise<Connection>;
}
